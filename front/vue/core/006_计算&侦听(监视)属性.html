<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>计算属性</title>
    <script type="text/javascript" src="../js2/vue.js"></script>
</head>
<body>
<!--插值实现-->
<div id="chazhi">
    <input type="text" v-model="firstName"><br><br>
    <input type="text" v-model="lastName"><br><br>
    全名：<span>{{ firstName }} - {{ lastName }}</span>
</div>

<script type="text/javascript">
    new Vue({
        el: "#chazhi",
        data: {
            firstName: "张",
            lastName: "三"
        }
    })
</script>
<hr>


<!--methods实现-->
<div id="meth">
    <input type="text" v-model="firstName"><br><br>
    <input type="text" v-model="lastName"><br><br>
    全名：<span>{{ fullName() }}</span>
</div>

<script type="text/javascript">
    new Vue({
        el: "#meth",
        data: {
            firstName: "张",
            lastName: "三"
        },
        methods: {
            fullName() {
                return this.firstName + ' - ' + this.lastName
            }
        }
    })
</script>
<hr>
<!--计算属性-->
<!--
计算属性：
  1.定义：要用的属性不存在，要通过已有属性(不能是随便的已有的什么变量)计算得来。
  2.原理：底层借助了Object.defineProperty方法提供的getter和setter。
  3.get函数什么时候执行？
        (1).初次读取时会执行一次。
        (2).当依赖的数据发生改变时会被再次调用。
  4.优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。
  5.备注：
      1.计算属性最终会出现在vm上，直接读取使用即可。
      2.如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。
-->
<div id="comp">
    <input type="text" v-model="firstName"><br><br>
    <input type="text" v-model="lastName"><br><br>
    全名：<span>{{ fullName }}</span><br>
    全名：<span>{{ fullName2 }}</span>
</div>

<script type="text/javascript">
    let vm = new Vue({
        el: "#comp",
        data: {
            firstName: "张",
            lastName: "三"
        },
        computed: {
            fullName: {
                //只要有人读取fullName就会调用get(),并且get中的this会被vue调为vue实例
                //get被调用的时机
                //1：初次读取fullName（多次调用get只会被调用一次，比methods有优势，methods没有缓存）
                //2：所依赖的数据发生变化时
                get() {
                    return this.firstName + ' - ' + this.lastName
                },
                //当fullName被修改时，set方法被调用
                set(value) {
                    const arr = value.split(' - ')
                    this.firstName = arr[0]
                    this.lastName = arr[1]
                }
            },
            //如果确定只用get方法，计算属性可以有以下简写方式
            fullName2() {
                return this.firstName + ' - ' + this.lastName
            }
        }
    })
</script>


<!--监视属性-->
<div id="wat">
    <h2>今天天气很{{ info }}</h2><br><br>
    <button @click="changeWeather">切换天气</button>
</div>

<script type="text/javascript">
    const vv = new Vue({
        el: "#wat",
        data: {
            isHot: true,
            pp: {
                a: 1,
                b: 2,
                c: {
                    c1: true
                }
            },
            mm: 123
        },
        methods: {
            changeWeather() {
                this.isHot = !this.isHot
            }
        },
        computed: {
            info() {
                return this.isHot ? '炎热' : '凉爽'
            }
        },
        watch: {
            isHot: {
                // 当isHot发生变动时handler方法被调用
                handler(newValue, oldValue) {
                    console.log("handler", oldValue, newValue)
                }
            },
            pp: {
                immediate: true,//加载时立即执行
                deep: true,//深度监视，vue默认只监视属性本身的变化，配置deep=true可以监视多级属性的变更
                handler(newValue, oldValue) {
                    console.log("deephandler", oldValue, newValue)
                }
            },
            //只有handler方法时可以用以下简写形式
            mm(oldValue, newValue) {
            }
        }
    })
    // watch另一种写法
    // vv.$watch('isHot', {
    //     handler(oldValue, newValue) {
    //         console.log("handler", oldValue, newValue)
    //     }
    // })
    // 简写
    // vv.$watch('isHot', function (newValue, oldValue) {
    //
    // })
</script>


<!--
computed和watch之间的区别：
    1.computed能完成的功能，watch都可以完成。
    2.watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。
两个重要的小原则：
      1.所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。
      2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数，
        这样this的指向才是vm 或 组件实例对象。
-->

</body>
</html>