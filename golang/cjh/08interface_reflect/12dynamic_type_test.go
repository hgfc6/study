package _8interface_reflect

import "log"

// 和其它语言相比，Go 是唯一结合了接口值，静态类型检查（是否该类型实现了某个接口），运行时动态转换的语言，并且不需要显式地声明类型是否满足某个接口。
// 该特性允许我们在不改变已有的代码的情况下定义和使用新接口。
// 接收一个（或多个）接口类型作为参数的函数，其实参可以是任何实现了该接口的类型的变量，类似python和Ruby的"duck typing"，它们能做什么比它们是什么更重要

// 提取接口 是非常有用的设计模式，可以减少需要的类型和方法数量，而且不需要像传统的基于类的面向对象语言那样维护整个的类层次结构。
// Go 接口可以让开发者找出自己写的程序中的类型。假设有一些拥有共同行为的对象，并且开发者想要抽象出这些行为
// 你不用提前设计出所有的接口；整个设计可以持续演进，而不用废弃之前的决定。类型要实现某个接口，它本身不用改变，你只需要在这个类型上实现新的方法。

// 如果你希望满足某个接口的类型显式地声明它们实现了这个接口，你可以向接口的方法集中添加一个具有描述性名字的方法。

type Fooer interface {
	Foo()
	ImplementsFooer()
}

// 类型 Bar 必须实现 ImplementsFooer 方法来满足 Fooer 接口，以清楚地记录这个事实。
type Bar struct{}

func (b Bar) ImplementsFooer() {}
func (b Bar) Foo()             {}

// 函数重载
// 虽然语法层面不允许，但是我们可用可变参数...T作为函数的最后一个参数来实现，如果T为空接口，那么就允许任何参数传递进来
// fmt.Printf(format string, a ...interface{})就是这样

// 接口继承
// 当一个类型包含（内嵌）另一个类型（实现了一个或多个接口）的指针时，这个类型就可以使用（另一个类型）所有的接口方法。
// 类型可以通过继承多个接口来提供像 多重继承 一样的特性
type Task struct {
	Command string
	*log.Logger
}

// Task.Log()
