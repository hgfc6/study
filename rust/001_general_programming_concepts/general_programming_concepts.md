# 通用编程概念

## [变量和可变性](./variables/src/main.rs)

`变量variables`,`常量constant`,`遮蔽shadow`

## 数据类型

`标量类型scalar`,`复合类型compound type`
Rust 是一种静态类型（statically typed）的语言，这意味着它必须在编译期知道所有变量的类型。
编译器通常可以根据值和使用方式推导出我们想要使用的类型

#### 标量类型
标量类型表示单个值
Rust 有 4 个基本的标量类型：整型、浮点型、布尔型和字符

**整数**

| 长度   | 有符号类型 | 无符号类型 |
|------|-------|-------|
| 8位   | i8    | u8    |
| 16位  | i16   | u16   |
| 32位  | i32   | u32   |
| 64位  | i64   | u64   |
| 128位 | i128  | u128  |
| arch | isize | usize |

arch表示根据计算机系统判定长度 若使用 64 位架构系统则为 64 位，若使用 32 位架构系统则为 32 位。
可能属于多种类型的还可以使用类型后缀来表示，例如33u8 表示无符号的8位整型
数字字面量还可以使用 _ 作为可视分隔符以方便读数，如 1_000，此值和 1000 相同

| 数字字面量       | 	示例         |
|-------------|-------------|
| 十进制	        | 98_222      |
| 十六进制        | 	0xff       |
| 八进制         | 	0o77       |
| 二进制	        | 0b1111_0000 |
| 字节 (仅限于 u8) | 	b'A'       |

**浮点数**

`f32`,`f64(默认)`

**数字运算**

`+` `-` `*` `/` `%`

**字符类型**

`char`
```rust
let c: char = 'A';
```

#### 复合类型
复合类型（compound type）可以将多个值组合成一个类型。
Rust 有两种基本的复合类型：元组（tuple）和数组（array）。

**元组**：元组是将多种类型的多个值组合到一个复合类型中的一种基本方式。元组的长度是固定的：声明后，它们就无法增长或缩小。元组允许元素类型不同
```rust
let tup: (i32, f64, u8) = (500, 6.4, 1);
```
**数组**：与元组不同，数组的每个元素必须具有相同的类型。与某些其他语言中的数组不同，Rust 中的数组具有固定长度。
```rust
let a = [1, 2, 3, 4, 5];
// 指定元素类型和长度
let a: [i32; 5] = [1, 2, 3, 4, 5];
// 如果要为每个元素创建包含相同值的数组，可以指定初始值，后跟分号，然后在方括号中指定数组的长度
let a = [3; 5]
```

## 函数
```rust
//定义
fn 函数名(参数一:参数一类型, 参数二:参数二类型) -> 返回值类型 {
    // 使用return可以提前返回结果，如果是最后一行就是返回结果，可以省略return, 这时最后一行不能带分号
}
//两数相加
fn add(n1:i32, n2:i32) -> i32 {
    n1 + n2
}
```

## 注释
`//`单行注释
`///`文档注释，支持markdown语法
## 控制流

**if else if else**
```rust
if condition1 {

} else if condition2 {

} else {

}
//或者将if else 返回值赋值给一个变量
let condition = true
let num = if condition {5} else {6}
println!("{}", num)//5
//但是这样就不对
let num = if condition {5} else {"6"}// error[E0308]: `if` and `else` have incompatible types
// 因为变量必须只有一个类型。Rust 需要在编译时就确切地知道 num 变量的类型
// 若 num 的类型仅在运行时确定，则 Rust 将无法做到这一点；而且若编译器必须跟踪任意变量的多种假设类型，则编译器会变得更复杂，并且对代码的保证也会减少。
```

**loop**，**while**，**for**
```rust
//loop{}=while true {}
//loop还可以配合循环标签跳转到指定位置
't1: loop {
    loop {
        break 't1;
    }
}
// break还可以返回循环的值
let mut n = 0
let num = loop {
    n+=1
    if n > 10 {
        break n * 2;
    }
}
println!("{}", num); // 22

let arr = [1, 2, 3]
for ele in arr {
    println!("{}", ele);
}
```